package avx

import (
	"bytes"
	"testing"
)

func TestExpandKeySM4(t *testing.T) {
	enc := make([]uint32, 32)
	expected := []uint32{0xf12186f9, 0x41662b61, 0x5a6ab19a, 0x7ba92077, 0x367360f4, 0x776a0c61, 0xb6bb89b3, 0x24763151, 0xa520307c, 0xb7584dbd, 0xc30753ed, 0x7ee55b57, 0x6988608c, 0x30d895b7, 0x44ba14af, 0x104495a1, 0xd120b428, 0x73b55fa3, 0xcc874966, 0x92244439, 0xe89e641f, 0x98ca015a, 0xc7159060, 0x99e1fd2e, 0xb79bd80c, 0x1d2115b0, 0xe228aeb, 0xf1780c81, 0x428d3654, 0x62293496, 0x1cf72e5, 0x9124a012}
	key := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}
	ExpandKey(enc, key)
	for i := 0; i < 32; i++ {
		if expected[i] != enc[i] {
			t.Errorf("expected[%d] = %x; got %x", i, expected[i], enc[i])
		}
	}
}

func TestSM4(t *testing.T) {
	src := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}
	encKey := []uint32{0xf12186f9, 0x41662b61, 0x5a6ab19a, 0x7ba92077, 0x367360f4, 0x776a0c61, 0xb6bb89b3, 0x24763151, 0xa520307c, 0xb7584dbd, 0xc30753ed, 0x7ee55b57, 0x6988608c, 0x30d895b7, 0x44ba14af, 0x104495a1, 0xd120b428, 0x73b55fa3, 0xcc874966, 0x92244439, 0xe89e641f, 0x98ca015a, 0xc7159060, 0x99e1fd2e, 0xb79bd80c, 0x1d2115b0, 0xe228aeb, 0xf1780c81, 0x428d3654, 0x62293496, 0x1cf72e5, 0x9124a012}
	expected := []byte{0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46}
	result := make([]byte, 16)
	Encrypt(result, src, (*[32]uint32)(encKey))
	if !bytes.Equal(result, expected) {
		t.Errorf("expected = %x; got %x", expected, result)
	}
	// decrypt
	decKey := make([]uint32, 32)
	for i := 0; i < 32; i++ {
		decKey[i] = encKey[31-i]
	}
	Encrypt(result, expected, (*[32]uint32)(decKey))
	if !bytes.Equal(result, src) {
		t.Errorf("expected = %x; got %x", src, result)
	}
}
