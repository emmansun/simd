package avx

import (
	"bytes"
	"testing"

	"github.com/emmansun/simd/alg/sm4"
	"github.com/emmansun/simd/amd64/sse"
)

func TestExpandKeySM4(t *testing.T) {
	enc := make([]uint32, 32)
	expected := []uint32{0xf12186f9, 0x41662b61, 0x5a6ab19a, 0x7ba92077, 0x367360f4, 0x776a0c61, 0xb6bb89b3, 0x24763151, 0xa520307c, 0xb7584dbd, 0xc30753ed, 0x7ee55b57, 0x6988608c, 0x30d895b7, 0x44ba14af, 0x104495a1, 0xd120b428, 0x73b55fa3, 0xcc874966, 0x92244439, 0xe89e641f, 0x98ca015a, 0xc7159060, 0x99e1fd2e, 0xb79bd80c, 0x1d2115b0, 0xe228aeb, 0xf1780c81, 0x428d3654, 0x62293496, 0x1cf72e5, 0x9124a012}
	ck := &sse.XMM{}
	fk := &sse.XMM{}
	key := &sse.XMM{}
	flip_mask := &sse.XMM{}
	VMOVDQU_L16B(flip_mask, []byte{0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04, 0x0b, 0x0a, 0x09, 0x08, 0x0f, 0x0e, 0x0d, 0x0c})
	VMOVDQU_L16B(key, []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10})
	VPSHUFB(key, key, flip_mask)
	VMOVDQU_L4S(fk, sm4.FK[:])
	VPXOR(key, fk, key)

	for i := 0; i < 32; i += 4 {
		VMOVDQU_L4S(ck, sm4.CK[i:])
		VSM4KEY4(key, key, ck)
		VMOVDQU_S4S(enc[i:], key)
	}
	for i := 0; i < 32; i++ {
		if expected[i] != enc[i] {
			t.Errorf("expected[%d] = %x; got %x", i, expected[i], enc[i])
		}
	}
}

func TestSM4(t *testing.T) {
	src := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}
	encKey := []uint32{0xf12186f9, 0x41662b61, 0x5a6ab19a, 0x7ba92077, 0x367360f4, 0x776a0c61, 0xb6bb89b3, 0x24763151, 0xa520307c, 0xb7584dbd, 0xc30753ed, 0x7ee55b57, 0x6988608c, 0x30d895b7, 0x44ba14af, 0x104495a1, 0xd120b428, 0x73b55fa3, 0xcc874966, 0x92244439, 0xe89e641f, 0x98ca015a, 0xc7159060, 0x99e1fd2e, 0xb79bd80c, 0x1d2115b0, 0xe228aeb, 0xf1780c81, 0x428d3654, 0x62293496, 0x1cf72e5, 0x9124a012}
	expected := []byte{0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46}
	data := &sse.XMM{}
	rk := &sse.XMM{}
	flip_mask := &sse.XMM{}
	bswap_mask := &sse.XMM{}
	VMOVDQU_L16B(flip_mask, []byte{0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04, 0x0b, 0x0a, 0x09, 0x08, 0x0f, 0x0e, 0x0d, 0x0c})
	VMOVDQU_L16B(bswap_mask, []byte{0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00})
	VMOVDQU_L16B(data, src)
	VPSHUFB(data, data, flip_mask)
	for i := 0; i < 32; i += 4 {
		VMOVDQU_L4S(rk, encKey[i:])
		VSM4RNDS4(data, data, rk)
	}
	VPSHUFB(data, data, bswap_mask)
	result := make([]byte, 16)
	VMOVEDQU_S16B(result, data)
	if !bytes.Equal(result, expected) {
		t.Errorf("expected = %x; got %x", expected, result)
	}
	// decrypt
	decKey := make([]uint32, 32)
	for i := 0; i < 32; i++ {
		decKey[i] = encKey[31-i]
	}
	VMOVDQU_L16B(data, expected)
	VPSHUFB(data, data, flip_mask)
	for i := 0; i < 32; i += 4 {
		VMOVDQU_L4S(rk, decKey[i:])
		VSM4RNDS4(data, data, rk)
	}
	VPSHUFB(data, data, bswap_mask)
	VMOVEDQU_S16B(result, data)
	if !bytes.Equal(result, src) {
		t.Errorf("expected = %x; got %x", src, result)
	}
}
